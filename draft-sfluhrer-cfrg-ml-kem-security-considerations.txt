



Crypto Forum                                                  S. Fluhrer
Internet-Draft                                             Cisco Systems
Intended status: Informational                            4 October 2024
Expires: 7 April 2025


                     ml-kem-security-considerations
       draft-sfluhrer-cfrg-ml-kem-security-considerations-latest

Abstract

   NIST standardized ML-KEM as FIPS 203 in August 2024.  This document
   discusses how to use ML-KEM - that is, what problem it solves, and
   how to use it securely.

Discussion Venues

   This note is to be removed before publishing as an RFC.

   Discussion of this document takes place on the Crypto Forum Research
   Group mailing list (cfrg@ietf.org), which is archived at
   https://mailarchive.ietf.org/arch/browse/cfrg.

   Source for this draft and an issue tracker can be found at
   https://github.com/sfluhrer/ml-kem-security-considerations.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 7 April 2025.

Copyright Notice

   Copyright (c) 2024 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.

Table of Contents

   1.  Introduction
   2.  Using ML-KEM
     2.1.  ML-KEM Key Generation
     2.2.  ML-KEM Encapsulation
     2.3.  ML-KEM Decapsulation
     2.4.  ML-KEM Parameter sets
   3.  Conventions and Definitions
   4.  KEM Security Considerations
   5.  ML-KEM Security Considerations
   6.  IANA Considerations
   7.  Normative References
   Acknowledgments
   Author's Address

1.  Introduction

   A large reliable Quantum Computer (often termed a Cryptographically
   Relevant Quantum Computer or CRQC) would be able to break protocols
   which rely on the tradtional RSA, DH or ECDH methods of securely
   exchanging keys.  Even though we do not believe, at the time of this
   writing, there exists a CRQC, there still remains the possibility
   that a adversary may record the protocol exchange, and then later
   (when they have access to a CRQC) go ahead and read the traffic.

   Because of this potential threat, NIST has standardized ML-KEM
   (Module-Lattice-Based Key-Encapsulation Mechanism), which is
   standardized in FIPS 203.  ML-KEM is used to generate a shared secret
   between two parties.  One party (Alice) generates a public/private
   keypair, and sends the public key to the other side (Bob).  Bob uses
   the public key and some randomness to generate both the shared secret
   and a ciphertext.  Bob then sends the ciphertext to Alice, who uses
   her private key to generate the same shared secret.

   The fundamental security propery is that someone listening to the
   exchanges (and thus obtains both the public key and the ciphertext)
   cannot reconstruct the shared secret; and this is true even if the
   adversary has access to a CRQC.

   ML-KEM is what is termed a Key Encapsulation Mechanism.  One common
   misunderstanding of that term is the expectation that Bob freely
   chooses the shared secret, and encrypts that when sending to Alice.
   What happens instead is that randomness from both sides are used to
   contribute to the shared secret.  That is, ML-KEM internally
   generates the shared secret in a way that Bob cannot select the
   value.  Now, Bob can generate a number of ciphertext/shared secret
   pairs, and select the shared secret that he prefers, but he cannot
   freely choose it.

   A KEM (such as ML-KEM) sounds like it may be a drop-in replacement
   for Diffie-Hellman, however there is one scenario where this doesn't
   work.  If the protocol uses DH in a 'static-static' configuration,
   that is, if both sides have long-term public keys, then ML-KEM is not
   suitable.  That is because the ciphertext is necessarily a function
   of Alice's public key, and thus can only be useful only with that
   specific public key.

2.  Using ML-KEM

   To use ML-KEM, there are three steps involved

2.1.  ML-KEM Key Generation

   The first step for Alice is to generate a public and private keypair.

   In FIPS 203, this function is termed ML-KEM.KeyGen() (see section
   7.1).  It internally calls the random number generator for a seed and
   produces both a public key (termed an encapsulation key in FIPS 203)
   and a private key (termed a decapsulation key).

   The public key can be freely published (and Bob will need it for his
   part of the process); this step may be performed simply by
   transmitting the key to Bob.  However, the private key must be kept
   secret.

2.2.  ML-KEM Encapsulation

   The second step is for Bob to generate a ciphertext and shared
   secret.

   To perform this step, Bob would first run the Encapsulation Key Check
   on Alice's public key as outlined at the beginning of section 7.2.
   If that test passes, then Bob would perform the what FIPS 203 terms
   as ML-KEM.Encaps() (see section 7.2).  This step takes the validated
   public key, internally calls the random number generator for a seed,
   and produces both a ciphertext and a 32 byte shared secret.

   The ciphertext can be transmitted back to Alice; if the exchange is
   successful, the 32 byte shared secret will be the value shared with
   Alice.

   It may be that some libraries combine the validation and the
   encapsulation step; you should check whether the library you are
   using does.

2.3.  ML-KEM Decapsulation

   The third and final step is for Alice to take the ciphertext and
   generate the shared secret.

   To perform this step, Alice would first run the Decapsulation Key
   Check on Bob's ciphertext as outlined at the beginning of section
   7.3.  If that test passes, then Bob would perform the what FIPS 203
   terms as ML-KEM.Decaps() (see section 7.3).  This step takes the
   ciphertext from Bob and the private key that was previously generated
   by Alice, and produces a 32 byte shared secret.

   If the exchange is successful, the 32 byte value generated on both
   sides will be the same.

   It may be that some libraries combine the validation and the
   decapsulation step; you should check whether the library you are
   using does.

2.4.  ML-KEM Parameter sets

   ML-KEM comes with three parameter sets; ML-KEM-512, ML-KEM-768 and
   ML-KEM-1024.  It is assumed that Alice and Bob both know which
   parameter sets they use (either by negotiation or by having one
   selection fixed in the protocol).

   Here is a summary of how those parameter sets differ:

    +=============+=========+=========+=========+=========+===========+
    |             | pk size | sk size | ct size | ss size | as strong |
    |             |         |         |         |         |     as    |
    +=============+=========+=========+=========+=========+===========+
    | ML-KEM-512  |     800 |    1632 |     768 |    32   |  AES-128  |
    +-------------+---------+---------+---------+---------+-----------+
    | ML-KEM-768  |    1184 |    2400 |    1088 |    32   |  AES-192  |
    +-------------+---------+---------+---------+---------+-----------+
    | ML-KEM-1024 |    1568 |    3168 |    1568 |    32   |  AES-256  |
    +-------------+---------+---------+---------+---------+-----------+

                                  Table 1

   (pk = public key, sk = private key, ct = ciphertext, ss = shared
   secret, all lengths in bytes)

3.  Conventions and Definitions

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

   I don't know if we need anything in this section.

4.  KEM Security Considerations

   This section pertains to KEM (Key Encapsulation Mechanisms) in
   general, including ML-KEM

   To use a KEM, you need to use good random bits (better terminology
   here please) during both the public key generation and ciphertext
   generation steps.  If an adversary can recover the random bits used
   in either of these processes, he can recover the shared secret.

   Alice needs to keep her private key secret.  It is recommended that
   she zeroize her private key when she will have no further need of it.

   A KEM provides no authentication; it is important that the protocol
   that uses a KEM lets Bob be able to verify that the public key he
   obtains comes from Alice and that the ciphertext that Alice receives
   came from Bob (that is, an entity that Alice is willing to
   communicate with).

5.  ML-KEM Security Considerations

   This section pertains specifically to ML-KEM; this is in addition to
   the security considerations that apply to all KEMs

   If the ciphertext that Alice receives from Bob is tampered with
   (either by small modification or by replacing it with an entirely
   different ciphertext), the shared secret that Alice derives will be
   uncorrelated with the shared secret that Bob obtains.  An attacker
   will not be able to determine any information about the correct
   shared secret or Alice's private key, even if he obtains Alice's
   modified shared secret.

   It is secure to reuse a public key multiple times.  That is, instead
   of Alice generating a fresh public and private keypair for each
   exchange, Alice may generate a public key once, and then publish that
   public key, and use it for multiple incoming ciphertexts, generating
   multiple shared secrets.  While this is safe, it is recommended that
   if the protocol allows it (if Alice and Bob exchange messages
   anyways) that Alice generates a fresh keypair each time (and zeroize
   the private key immediately after) to obtain Perfect Forward Secrecy.
   That is, if Alice's system is subverted (either by a hacker or a
   legal warrent), the previous communications remain secure (because
   Alice no longer has the information needed to recover the shared
   secret).

   The shared secret for all three parameter sets are 32 bytes which are
   indistinguishable from random (by someone observing only the public
   key and the ciphertext).  As such, it is suitable both to use
   directly as symmetric keying material, and for inserting into a Key
   Derivation Function.  This is in contrast to a Diffie-Hellman (or
   ECDH) operation, where the output is distinguishable from random.

6.  IANA Considerations

   This document has no IANA actions.

7.  Normative References

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/rfc/rfc2119>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/rfc/rfc8174>.

Acknowledgments

Author's Address

   Scott Fluhrer
   Cisco Systems
   Email: sfluhrer@cisco.com
